# Сервис CheckLink

Сервис CheckLink предназначен для валидации и проверки работоспособности ссылок на сайты.

## Обзор работы программы

Пробежимся по программе и рассмотрим, что она выполняет, какие паттерны и методы были применены в ходе её выполнения.

Сама программа представляет собой REST API‑приложение, написанное на языке Go (версия 1.25.0), которое принимает запросы по следующим адресам:

1. **`/links` (POST)**  
   - Формат запроса (JSON):  
     ```json
     {"links": ["google.com", "mailformedlink.gg"]}
     ```
   - Может принимать как одно, так и множество значений.
   - Приложение производит проверку ссылок из запроса на валидность и выдаёт ответ в формате:  
     ```json
     {"links": {"google.com": "available", "mailformedlink.gg": "not available"}, "links_num": 1}
     ```

2. **`/links/report` (POST)**  
   - Формат запроса (JSON):  
     ```json
     {"links_list": [1, 2]}
     ```
   - В ответ выдаётся отчёт в формате PDF.

## Структура проекта

Сам сервис чётко разбит на слои, реализация которых скрыта за интерфейсами:
- `handler`
- `service`
- `storage`
- `client`

### Слой storage

Так как в задании прописано, что использовать внешнюю инфраструктуру не нужно, само хранилище представлено в двух реализациях:

1. Во время работы сервиса мы используем мапы с мьютексами, так как мапа в Go конкурентно не безопасная.
2. Локальное хранилище в виде JSON‑файлов, куда все данные сохраняются при остановке сервиса.

Для всего этого было реализовано 3 модуля:

#### 1. FileStorage

Основная задача — сохранение данных в файлы при завершении работы и загрузка данных обратно в мапы при возобновлении работы сервиса.

**Реализует следующие методы:**
- `LoadLinks` — чтение файла с данными о ранее сделанных запросах клиентов на проверку ссылок; парсинг этих данных в структуру и передача данных.
- `LoadTasks` — делает всё то же самое, что и `LoadLinks`, только с задачами, которые прилетали во время остановки сервиса (graceful shutdown).
- `SaveLoadLinks` / `SaveLoadTasks` — преобразуют структуры в байты и записывают их в соответствующие JSON‑файлы перед завершением работы сервиса.

#### 2. LinkStorage

Модуль хранилища, который хранит в себе все выполненные запросы. Основное хранение происходит в структуре `storage` в `map[int64]*domain.LinkBatch`.

В структуре есть:
- мьютекс (так как мапа является конкурентно не безопасной структурой, необходимо использовать его при каждой записи данных);
- counter, который поочерёдно выдаёт ID для нового пакета данных.

**Реализованные методы:**
- `SaveLinks` — сохранение новых данных в мапу.
- `NextID` — выдача нового ID.
- `GetByIds` — выдаёт слайс данных для дальнейшего формирования отчёта.
- `GetAllLinks` — отдаёт все данные, хранящиеся в мапе, вместе с последним ID; передаёт их для дальнейшего сохранения в локальной БД (файле).

#### 3. TasksStorage

Точно такой же модуль, только для хранения незавершённых задач (запросов), которые перед завершением работы сервиса собираются в этом хранилище и записываются для дальнейшей обработки после запуска сервиса.

**Реализуемые методы:**
- `SaveTask` — сохранение задачи.
- `GetAndCleanTasks` — логика метода в том, чтобы отдать все накопленные задачи либо в модуль для сохранения данных, либо в модуль для дальнейшей обработки. В любом случае данные в этой структуре нам не нужны, поэтому она очищается путём создания новой мапы.

### Слой service

Состоит из 4 основных сервисов:

#### 1. Checker

Выполняет задачи по проверке валидности ссылок.

**Реализует следующие методы:**
- `CheckLink` — проверяет отдельную ссылку на валидность:
  - проверяет наличие префикса `http://` или `https://` (если отсутствует — добавляет);
  - вызывает метод клиента `CheckLink` (происходит процесс запроса по ссылке, в ответ получаем `status` и `ошибку`);
  - если ошибка есть, считаем сайт недоступным;
  - если пришёл статус, проверяем его валидность (должен быть в диапазоне 200–400), иначе ссылка не активная.
- `CheckBatch` — ключевой метод в проверке больших объёмов ссылок, позволяет параллельно запускать проверку множества ссылок.

  **Реализация:**
  - принимается слайс ссылок;
  - создаются два буферизированных канала (`error`, `result`) для накопления результатов и последующей конвертации в необходимую структуру после завершения выполнения горутин;
  - для контроля количества одновременно запущенных горутин используется семафор (реализован при помощи буферизированного канала: при запуске горутины записывается пустая структура в канал, а в конце выполнения — читается из канала, освобождая место для новой горутины);
  - для синхронизации выполнения горутин используется `sync.WaitGroup`:
    - перед запуском горутины увеличивается счётчик запущенных горутин (`wg.Add(1)`);
    - после завершения горутины вызывается `wg.Done`;
    - в месте, где необходимо дождаться выполнения всех горутин, ставится `wg.Wait`;
  - каналы закрываются, из них читается информация, вызываются методы сохранения данных в БД.

#### 2. LinkReport

Сервис для создания отчётов в формате PDF.

**Реализуется один метод:**
- `CreateReport` — получает данные для составления отчёта из БД, использует собственную обёртку (`pkg/pdf`) над `gofpdf` для создания PDF‑отчёта и передаёт созданный отчёт дальше.

#### 3. Save

Сервис по сохранению данных в файлы. Запрашивает в `LinkStorage` и `TaskStorage` мапу со всеми сохранёнными данными и пробрасывает их в `FileStorage` для сохранения в файлы.

**Применяется в двух случаях:**
1. Перед закрытием — вызываются оба метода.
2. Во время работы scheduler — с определённым интервалом сохраняет данные из `LinkStorage` в локальную БД.

#### 4. Task

Сервис обрабатывает незавершённые таски.

**Реализует два метода:**
1. `SaveTask` — принимает таску и прокидывает её в БД. Вызывается из middleware, который при запуске процесса остановки отсекает все входящие запросы и перенаправляет их в БД через Task‑сервис для последующей обработки при следующем запуске сервера.
2. `ProcessPendingTasks` — занимается дообработкой таких запросов:
   - получает из БД все необработанные запросы;
   - через отдельные горутины запускает метод клиента `TaskWorker`, который делает запросы в наш же сервис, дообрабатывая задачи.

### Слой handler

Рассматривать подробно не требуется: принял данные, перекинул в сервисный слой — всё просто.

### Middleware

Реализован `GracefulShutDownMiddleware`, который выполняет ключевую роль при остановке сервера.

**Почему это важно?**  
В ТЗ указано, что запросы должны поступать при отключении. Вот как работает отключение сервера с этим middleware:

1. Поступает сигнал о завершении в канал `<-quit`.
2. Сразу подаётся флаг в middleware о том, чтобы он не отправлял новые запросы на обработку в хендлеры, а сам обработал запрос и направил его на сохранение в БД.
3. Основная горутина `main` засыпает на 30 секунд — в этот момент трудозатратные процессы выполняются, а middleware прокидывает все запросы в БД для дальнейшей обработки.
4. Далее вызывается `shutdown` с таймаутом:
   - отключается прослушивание входящих запросов;
   - ожидается завершение всех процессов, если они ещё не завершились.
5. После завершения всех процессов данные сохраняются, и работа завершается.

### Дополнительные компоненты

В проекте реализован простой DI‑контейнер для инициализации всех зависимостей.

## Текущее состояние проекта

В проекте ещё **не реализовано**:
- конфигурационный файл;
- полное логирование;
- оборачивание всех ошибок;
- стандартизированные структуры для ответов в хендлерах;
- полноценно реализованный клиент (так как большинство сайтов отсекает запросы как ботовые).


В целом, вот такой сервис. Потрачено много сил и времени.
